<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Origami Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            /* ROYAL BLUE BACKGROUND: Radial Gradient Deep Blue */
            background: radial-gradient(circle at 50% 50%, #1E3A8A 0%, #0A1C40 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            display: block; 
        }
        
        /* Custom Scrollbar for the panel */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        .glass-panel {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(16px);
            border-left: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: -10px 0 30px rgba(0,0,0,0.5);
            transition: all 0.3s ease-in-out; 
        }

        /* Folded State Styling */
        .glass-panel.folded {
            width: 4rem; 
            transform: translateX(calc(100% - 4rem)); 
        }
        .glass-panel.folded .panel-content, .glass-panel.folded .panel-footer {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        .glass-panel.folded .panel-header {
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            border-bottom: none;
        }

        /* Range Slider Styling - Coral Palette */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #FE8A7E; /* Light Coral/Salmon - Keeping slider color distinct */
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(254, 138, 126, 0.8);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px;
        }
        
        /* Morphing Button Style - START State (Coral Gradient) */
        #start-morph-btn {
            background: linear-gradient(90deg, #FE8A7E 0%, #FD6A6A 100%);
            color: #1e293b;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(253, 106, 106, 0.4);
            transition: all 0.2s ease;
        }
        /* Morphing Button Style - RUNNING State (Red) */
        #start-morph-btn.running {
            background: linear-gradient(90deg, #dc2626 0%, #b91c1c 100%); /* Retaining Red for "Stop" for urgency */
            color: white;
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.4);
        }
        #start-morph-btn:hover:not(.running):not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(253, 106, 106, 0.6);
        }
        #start-morph-btn.running:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(220, 38, 38, 0.6);
        }
        #start-morph-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }
    </style>
</head>
<body>

    <!-- Main 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Overlay / Context Menu -->
    <div id="control-panel" class="fixed top-0 right-0 h-full w-80 glass-panel text-white z-10 flex flex-col shadow-2xl">
        
        <!-- Header -->
        <div class="panel-header p-6 border-b border-gray-700 bg-gradient-to-r from-gray-900 to-transparent flex items-center justify-between">
            <div class="panel-content overflow-hidden">
                <!-- UPDATED: Title color changed to text-amber-200 (champagne) and subtitle removed -->
                <h1 class="text-xl font-bold text-amber-200 tracking-wide uppercase whitespace-nowrap">Origami Viewer</h1>
            </div>
            <!-- Toggle Button -->
            <button id="toggle-panel-btn" class="text-gray-400 hover:text-white transition p-1 rounded-full hover:bg-gray-700 focus:outline-none ml-2" aria-label="Toggle Panel">
                <svg id="toggle-icon-open" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path></svg>
                <svg id="toggle-icon-closed" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path></svg>
            </button>
        </div>

        <!-- Controls Container -->
        <div class="panel-content flex-1 overflow-y-auto p-6 space-y-8">

            <!-- Morphing Trigger -->
            <div class="space-y-3">
                <h2 class="text-xs font-bold text-gray-500 uppercase tracking-widest border-l-2 border-yellow-500 pl-2">Conformation Change</h2>
                <button id="start-morph-btn" class="w-full p-4 rounded-xl text-lg uppercase tracking-wider">
                    Start Dynamic Morphing
                </button>
            </div>

            <!-- Global Controls -->
            <div class="space-y-3">
                <h2 class="text-xs font-bold text-gray-500 uppercase tracking-widest border-l-2 border-pink-500 pl-2">View Control</h2>
                
                <div class="flex items-center justify-between bg-gray-800/50 p-3 rounded-lg border border-gray-700 hover:border-gray-600 transition">
                    <span class="text-sm font-medium">Auto-Rotation</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="toggle-rotation" checked class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
                    </label>
                </div>

                <!-- UPDATED: Switch color changed to white/gray -->
                <div class="flex items-center justify-between bg-gray-800/50 p-3 rounded-lg border border-gray-700 hover:border-gray-600 transition">
                    <span class="text-sm font-medium">Backbone Mode</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="toggle-wireframe" class="sr-only peer">
                        <!-- Use peer-checked:bg-white to match the new white wireframe color -->
                        <div class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-blue-300 after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-white"></div>
                    </label>
                </div>
            </div>

            <!-- Entropy Controls -->
            <div class="space-y-3">
                <h2 class="text-xs font-bold text-gray-500 uppercase tracking-widest border-l-2 border-red-500 pl-2 flex items-center justify-between">
                    <span>Molecular Dynamics</span>
                </h2>
                
                <div class="bg-gray-800/50 p-4 rounded-lg border border-gray-700 space-y-4">
                    <div class="flex items-center justify-between">
                        <span class="text-sm font-medium text-gray-200">Thermal Entropy</span>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="toggle-entropy" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-red-600"></div>
                        </label>
                    </div>

                    <div class="space-y-2">
                        <div class="flex justify-between text-xs text-gray-400 font-mono">
                            <span>TEMP (K)</span>
                            <span id="entropy-val" class="text-pink-300">300</span>
                        </div>
                        <input type="range" id="entropy-scale" min="0.1" max="3.0" step="0.1" value="1.0">
                    </div>
                </div>
            </div>

            <!-- Shape Info -->
            <div class="space-y-3">
                <h2 class="text-xs font-bold text-gray-500 uppercase tracking-widest border-l-2 border-blue-500 pl-2">Grid Metrics</h2>
                <div class="grid grid-cols-2 gap-3">
                    <div class="bg-blue-900/20 p-3 rounded border border-blue-800/50 text-center backdrop-blur-sm">
                        <div class="text-2xl font-bold text-pink-300" id="shape-count">12</div>
                        <div class="text-[10px] text-blue-200 uppercase tracking-wide">Constructs</div>
                    </div>
                    <div class="bg-blue-900/20 p-3 rounded border border-blue-800/50 text-center backdrop-blur-sm">
                        <div class="text-2xl font-bold text-pink-300">4×3</div>
                        <div class="text-[10px] text-blue-200 uppercase tracking-wide">Matrix</div>
                    </div>
                </div>
            </div>

            <!-- Pattern List -->
            <div class="space-y-3">
                <h2 class="text-xs font-bold text-gray-500 uppercase tracking-widest border-l-2 border-green-500 pl-2">Topology Layers</h2>
                <div class="space-y-2" id="pattern-list">
                    <!-- JS will populate this -->
                </div>
            </div>

        </div>

        <!-- Footer -->
        <div class="panel-footer p-4 border-t border-gray-700 bg-gray-900/50 text-center text-[16px] text-gray-500 font-mono">
            © The Visual Hub 2026
        </div>
    </div>

    <script>
        // --- 1. CONFIGURATION ---
        const CONFIG = {
            grid: { rows: 3, cols: 4 }, 
            spacing: { x: 5.5, y: 5.5 }, 
            colors: {
                // ROYAL BLUE BACKGROUND for Fog
                background: 0x0A1C40, 
                shape: 0xF0F8FF, // Placeholder, actual color set below
                specular: 0xffffff    
            },
            cameraZ: 22,
            tube: { 
                segments: 200, 
                radius: 0.3, 
                radialSegments: 5, 
                closed: true 
            }
        };

        // --- 2. TEXTURE GENERATION (Procedural Bump Map) ---
        function createMolecularTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, size, size);

            for (let i = 0; i < 6000; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const r = Math.random() * 3 + 1;
                const shade = Math.floor(Math.random() * 60 + 100); 
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 1);
            return texture;
        }

        const molecularMap = createMolecularTexture();


        // --- 3. SETUP SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = null; 
        // Use new Royal Blue background for fog
        scene.fog = new THREE.Fog(CONFIG.colors.background, 20, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.cameraZ;

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 2.0;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- 4. LIGHTING & MATERIAL: VIBRANT ORANGE TONE ---
        
        // Ambient Light: Low intensity, deep cool color for subtle contrast
        const ambientLight = new THREE.AmbientLight(0x4A6FA5, 0.4); 
        scene.add(ambientLight);
        
        // Main Light: Soft white/yellow to intensely illuminate the orange
        const mainLight = new THREE.DirectionalLight(0xFFFFCC, 4.5); 
        mainLight.position.set(10, 20, 20);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);
        
        // Rim Light: Light Blue to provide crisp, cool edge highlights against the blue background
        const rimLight = new THREE.SpotLight(0x87CEFA, 6.0); 
        rimLight.position.set(-10, 10, -5);
        rimLight.lookAt(0, 0, 0);
        scene.add(rimLight);
        
        // Fill Light: Soft pink/magenta fill for deep saturation and contrast
        const fillLight = new THREE.PointLight(0xFF69B4, 2.5); 
        fillLight.position.set(0, -10, 10);
        scene.add(fillLight);

        // --- Vibrant Orange Material (Solid State) ---
        const MAIN_COLOR = 0xB22222; // HTML equivalent: #FF6600

        const proteinMaterial = new THREE.MeshPhysicalMaterial({
            color: MAIN_COLOR,                 // Base Vibrant Orange Color
            emissive: 0xFFD700,                    // Bright orange/yellow internal glow
            emissiveIntensity: 0.001,                // Slightly increased self-illumination
            metalness: 0.0,                        // CRITICAL: Non-metallic
            roughness: 0.5,                        // Matte surface (ceramic look)
            clearcoat: 0.5,                        // High clearcoat for elegant gloss
            clearcoatRoughness: 0.02,
            bumpMap: molecularMap,
            bumpScale: 0.1, 
            transparent: true,                     
            opacity: 0.9,                         
            side: THREE.FourSide
        });
        
        // --- NEW: Vibrant White Wireframe Material (Backbone/Trace State) ---
        const WHITE_WIREFRAME_MATERIAL = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF, // Pure Vibrant White
            wireframe: true,
            transparent: true,
            opacity: 0.9, // Slight transparency for a "trace" effect
            side: THREE.DoubleSide
        });
        
        // --- 5. PARAMETRIC CURVES (Dynamic Shape Definition) ---
        
        // Base class for curves that supports dynamic interpolation
        class DynamicCurve extends THREE.Curve {
            constructor(getPointFunc) {
                super();
                this.getPointFunc = getPointFunc;
            }
            getPoint(t, optionalTarget = new THREE.Vector3()) {
                return this.getPointFunc(t, optionalTarget);
            }
        }
        
        // A. Star Flower Cages (Row 0)
        function createStarFlowerCurve(scale, modA, modB) {
            const s = scale * 0.7 * 0.7;
            return new DynamicCurve((t, target) => {
                const u = t * Math.PI * 2;
                const R = 2.0; 
                const r = 0.8;
                
                const radiusMod = R + r * Math.sin(modA * u); 
                
                const x = radiusMod * Math.cos(u * modA / 2.5);
                const y = radiusMod * Math.sin(u * modA / 2.5);
                const z = r * Math.cos(modB * u) * 0.7;
                
                return target.set(x, y, z).multiplyScalar(s);
            });
        }

        // B. Polyhedral Cage (Row 1)
        function createPolyhedralCageCurve(scale, p, q) {
            const s = scale * 0.6 * 0.7;
            return new DynamicCurve((t, target) => {
                const u = t * Math.PI * 2;
                
                const x = 3 * Math.cos(p * u) / 2 + 1.5 * Math.cos(u);
                const y = 3 * Math.sin(p * u) / 2 + 1.5 * Math.sin(u);
                const z = Math.sin(q * u) * 1.5;
                
                return target.set(x, y, z).multiplyScalar(s);
            });
        }

        // C. Hyper-Intertwined Structures (Row 2)
        function createHyperHelixCurve(scale, d, e) {
            const s = scale * 0.65 * 0.7;
            return new DynamicCurve((t, target) => {
                const u = t * Math.PI * 2;
                
                const R = 2.5 + 0.5 * Math.sin(u * 5);
                const x = R * Math.cos(u * 2) + 0.5 * Math.cos(d * u);
                const y = R * Math.sin(u * 2) + 0.5 * Math.sin(d * u);
                const z = Math.sin(e * u) * Math.cos(u);
                
                return target.set(x, y, z).multiplyScalar(s);
            });
        }
        
        const totalShapes = CONFIG.grid.rows * CONFIG.grid.cols; // 12
        const shapeData = []; // Stores the mesh and the curve definition

        // Grid Calculation
        const startX = -((CONFIG.grid.cols - 1) * CONFIG.spacing.x) / 2;
        const startY = ((CONFIG.grid.rows - 1) * CONFIG.spacing.y) / 2;
        
        // Function to define all 12 curves
        function createAllTargetCurves() {
            const curves = [];
            for (let i = 0; i < totalShapes; i++) {
                const row = Math.floor(i / CONFIG.grid.cols);
                const col = i % CONFIG.grid.cols;
                const seed = col;
                
                let curve;
                if (row === 0) {
                    curve = createStarFlowerCurve(1.0, 5 + seed, 3 + seed); 
                } else if (row === 1) {
                    curve = createPolyhedralCageCurve(1.0, 3 + seed % 2, 5 + seed);
                } else {
                    curve = createHyperHelixCurve(1.0, 4 + seed, 3 + seed % 3);
                }
                curves.push(curve);
            }
            return curves;
        }

        const allTargetCurves = createAllTargetCurves();

        // 6. INITIAL SETUP
        for (let i = 0; i < totalShapes; i++) {
            const initialCurve = allTargetCurves[i];

            // Use BufferGeometry for dynamic updates
            const geometry = new THREE.TubeGeometry(initialCurve, CONFIG.tube.segments, CONFIG.tube.radius, CONFIG.tube.radialSegments, CONFIG.tube.closed);
            
            // Clone the proteinMaterial for each mesh
            const originalMaterial = proteinMaterial.clone();
            const mesh = new THREE.Mesh(geometry, originalMaterial); 
            
            const row = Math.floor(i / CONFIG.grid.cols);
            const col = i % CONFIG.grid.cols;
            const gridX = startX + (col * CONFIG.spacing.x);
            const gridY = startY - (row * CONFIG.spacing.y);
            
            mesh.position.set(gridX, gridY, 0);
            mesh.rotation.set(Math.random() * Math.PI * 0.5, Math.random() * Math.PI * 0.5, 0);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            mesh.userData = {
                rotSpeedX: (Math.random() * 0.006) + 0.002, 
                rotSpeedY: (Math.random() * 0.006) + 0.002,
                originalPos: new THREE.Vector3(gridX, gridY, 0),
                floatOffset: Math.random() * Math.PI * 2,
                visible: true,
                entropyPhase: Math.random() * 100,
                
                // Morphing state properties
                initialCurve: initialCurve,
                targetCurve: initialCurve,
                morphFactor: 0.0, // Per-shape factor for seamless transition
                
                // Material references for toggling
                originalMaterial: originalMaterial,
                wireframeMaterial: WHITE_WIREFRAME_MATERIAL
            };

            scene.add(mesh);
            shapeData.push(mesh);
        }

        // --- 7. DYNAMIC MORPHING LOGIC ---

        const morphState = {
            isRunning: false, 
            cycleDuration: 3000, // 3 seconds per morph transition
        };
        
        /**
         * Custom curve for real-time interpolation between two dynamic curves.
         * Uses internal vectors (vStart, vEnd) for safe calculation.
         */
        class InterpolatingCurve extends THREE.Curve {
            constructor(initialCurve, targetCurve, blendFactor) {
                super();
                this.initialCurve = initialCurve;
                this.targetCurve = targetCurve;
                this.blendFactor = blendFactor;
                // Internal vectors for safe calculation within getPoint
                this.vStart = new THREE.Vector3(); 
                this.vEnd = new THREE.Vector3();   
            }

            getPoint(t, optionalTarget = new THREE.Vector3()) {
                // Get the point from the initial curve, storing it in vStart
                this.initialCurve.getPoint(t, this.vStart);
                
                // Get the point from the target curve, storing it in vEnd
                this.targetCurve.getPoint(t, this.vEnd);
                
                // Linear interpolation: P_morphed = P_start * (1-blend) + P_end * blend
                optionalTarget.x = this.vStart.x * (1 - this.blendFactor) + this.vEnd.x * this.blendFactor;
                optionalTarget.y = this.vStart.y * (1 - this.blendFactor) + this.vEnd.y * this.blendFactor;
                optionalTarget.z = this.vStart.z * (1 - this.blendFactor) + this.vEnd.z * this.blendFactor;
                
                return optionalTarget;
            }
        }
        
        /**
         * Updates the tube geometry based on the current morph factor.
         */
        function updateMorphGeometry(mesh, blendFactor) {
            const { initialCurve, targetCurve } = mesh.userData;
            
            // Create the interpolating curve instance
            const interpolatingCurve = new InterpolatingCurve(initialCurve, targetCurve, blendFactor);
            
            // Dispose old geometry (Crucial step for releasing memory before creating a new one)
            if (mesh.geometry) mesh.geometry.dispose();

            // Create new geometry from the interpolated curve, using the updated CONFIG
            const newGeometry = new THREE.TubeGeometry(interpolatingCurve, CONFIG.tube.segments, CONFIG.tube.radius, CONFIG.tube.radialSegments, CONFIG.tube.closed);
            mesh.geometry = newGeometry;
        }

        // --- 8. ANIMATION LOOP ---
        let isAutoRotating = true;
        let isEntropyActive = false;
        let entropyScale = 1.0; 
        let time = 0;
        let lastTimestamp = 0; // Tracks the last frame time for delta time calculation
        const morphButton = document.getElementById('start-morph-btn');

        function animate(timestamp) {
            requestAnimationFrame(animate);

            // Calculate delta time
            if (lastTimestamp === 0) lastTimestamp = timestamp;
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;
            
            time += 0.01; // Independent time for floating animation

            if (morphState.isRunning) {
                // Calculate step size based on duration
                const morphStep = deltaTime / morphState.cycleDuration;
                
                shapeData.forEach(mesh => {
                    const userData = mesh.userData;
                    
                    // Advance blend factor for this shape
                    userData.morphFactor += morphStep; 

                    // Check if blend cycle is complete
                    if (userData.morphFactor >= 1.0) {
                        // Swap the curves for the next cycle
                        userData.initialCurve = userData.targetCurve;
                        
                        // Select a new random target curve
                        let targetIndex;
                        do {
                            targetIndex = Math.floor(Math.random() * totalShapes);
                        } while (allTargetCurves[targetIndex] === userData.initialCurve); 
                        
                        userData.targetCurve = allTargetCurves[targetIndex];
                        
                        // Reset blend factor to the *remainder* (using modulo) to maintain continuity.
                        userData.morphFactor = userData.morphFactor % 1.0; 
                    }

                    // Apply easing function for smooth acceleration/deceleration
                    let easedBlend = 0.5 * (1 - Math.cos(Math.PI * userData.morphFactor)); 

                    updateMorphGeometry(mesh, easedBlend);
                });
            }


            shapeData.forEach((mesh) => {
                if (!mesh.userData.visible) return;

                // 1. Base Rotation 
                if (isAutoRotating) {
                    mesh.rotation.x += mesh.userData.rotSpeedX;
                    mesh.rotation.y += mesh.userData.rotSpeedY;
                }

                // 2. Base Position & Floating
                let targetX = mesh.userData.originalPos.x;
                let targetY = mesh.userData.originalPos.y + Math.sin(time + mesh.userData.floatOffset) * 0.1;
                let targetZ = mesh.userData.originalPos.z;

                // 3. Entropy (Thermal Vibration)
                if (isEntropyActive) {
                    const jitterTime = time * 25; 
                    const phase = mesh.userData.entropyPhase;
                    const amp = 0.1 * entropyScale; 
                    
                    const jitterX = (Math.sin(jitterTime + phase) * Math.cos(jitterTime * 0.9)) * amp;
                    const jitterY = (Math.cos(jitterTime + phase * 2) * Math.sin(jitterTime * 1.3)) * amp;
                    const jitterZ = (Math.sin(jitterTime * 1.5 + phase)) * amp;

                    mesh.rotation.z += (Math.random() - 0.5) * 0.05 * entropyScale;
                    
                    targetX += jitterX;
                    targetY += jitterY;
                    targetZ += jitterZ;
                }

                mesh.position.set(targetX, targetY, targetZ);
            });

            renderer.render(scene, camera);
        }

        animate(performance.now());


        // --- 9. UI INTERACTION ---
        
        // Morphing Trigger Handler
        morphButton.addEventListener('click', () => {
            morphState.isRunning = !morphState.isRunning;
            
            if (morphState.isRunning) {
                morphButton.textContent = "STOP CONTINUOUS MORPHING";
                morphButton.classList.add('running');
            } else {
                morphButton.textContent = "Start Dynamic Morphing";
                morphButton.classList.remove('running');
            }
        });

        // Panel Collapse/Fold Functionality
        const panel = document.getElementById('control-panel');
        const toggleButton = document.getElementById('toggle-panel-btn');
        const iconOpen = document.getElementById('toggle-icon-open');
        const iconClosed = document.getElementById('toggle-icon-closed');

        toggleButton.addEventListener('click', () => {
            const isFolded = panel.classList.toggle('folded');
            if (isFolded) {
                iconOpen.classList.add('hidden');
                iconClosed.classList.remove('hidden');
            } else {
                iconOpen.classList.remove('hidden');
                iconClosed.classList.add('hidden');
            }
            window.dispatchEvent(new Event('resize'));
        });

        // Rotation Toggle
        document.getElementById('toggle-rotation').addEventListener('change', (e) => {
            isAutoRotating = e.target.checked;
        });

        // Wireframe Toggle - NOW SWAPS MATERIALS
        document.getElementById('toggle-wireframe').addEventListener('change', (e) => {
            const isWireframe = e.target.checked;
            shapeData.forEach(mesh => { 
                if (isWireframe) {
                    // Switch to the vibrant white wireframe material
                    mesh.material = mesh.userData.wireframeMaterial; 
                } else {
                    // Revert to the opaque vibrant orange material
                    mesh.material = mesh.userData.originalMaterial;
                }
            });
        });

        // Entropy Toggle
        document.getElementById('toggle-entropy').addEventListener('change', (e) => {
            isEntropyActive = e.target.checked;
        });

        // Entropy Slider
        const entropySlider = document.getElementById('entropy-scale');
        const entropyValDisplay = document.getElementById('entropy-val');
        
        entropySlider.addEventListener('input', (e) => {
            entropyScale = parseFloat(e.target.value);
            const temp = Math.round(entropyScale * 300);
            entropyValDisplay.innerText = temp;
        });

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Pattern List (3 Rows)
        const patternList = document.getElementById('pattern-list');
        const labels = ["Star Flower Cages (Row 1)", "Polyhedral Cages (Row 2)", "Hyper-Intertwined (Row 3)"];
        
        for (let r = 0; r < 3; r++) {
            const div = document.createElement('div');
            div.className = "flex items-center justify-between p-2 bg-gray-800/30 rounded border border-gray-700/50 hover:bg-gray-800 transition cursor-pointer";
            div.innerHTML = `
                <span class="text-xs text-gray-300">${labels[r]}</span>
                <div class="w-2 h-2 rounded-full bg-green-500 status-dot shadow-[0_0_8px_rgba(34,197,94,0.6)]"></div>
            `;
            
            let active = true;
            div.addEventListener('click', () => {
                active = !active;
                div.querySelector('.status-dot').className = `w-2 h-2 rounded-full ${active ? 'bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]' : 'bg-red-500 shadow-[0_0_8px_rgba(239,68,68,0.6)]'} status-dot`;
                div.classList.toggle('opacity-50');
                
                const start = r * 4;
                const end = start + 4;
                for(let i=start; i<end; i++) {
                    if(shapeData[i]) {
                        shapeData[i].visible = active;
                        shapeData[i].userData.visible = active;
                    }
                }
            });

            patternList.appendChild(div);
        }

    </script>
</body>
</html>