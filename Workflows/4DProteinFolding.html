<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Protein Folding</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020612; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #fff; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(8, 12, 24, 0.85);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(65, 105, 225, 0.3);
            width: 340px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
        }

        #ui-layer::-webkit-scrollbar { width: 4px; }
        #ui-layer::-webkit-scrollbar-thumb { background: #4169E1; border-radius: 2px; }

        #ui-layer.collapsed {
            transform: translateX(-355px);
        }

        #toggle-ui-btn {
            position: absolute;
            right: 5px;
            top: 15px;
            width: 24px;
            height: 24px;
            background: rgba(65, 105, 225, 0.3);
            border: 1px solid rgba(65, 105, 225, 0.5);
            border-radius: 4px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: monospace;
            z-index: 11;
            transition: all 0.2s;
        }
        
        #toggle-ui-btn:hover {
            background: rgba(65, 105, 225, 0.8);
        }

        h1 { font-size: 16px; margin: 0 0 5px 0; letter-spacing: 1px; text-transform: uppercase; color: #4169E1; padding-right: 30px; }
        h2 { font-size: 12px; margin: 0 0 15px 0; color: #8899aa; font-weight: 400; }

        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 11px; color: #8899aa; margin-bottom: 5px; text-transform: uppercase; }
        
        input[type=range] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4169E1;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px #4169E1;
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #2a3b55;
            border-radius: 2px;
        }

        .seq-display {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #ccdbff;
            word-break: break-all;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 10, 30, 0.5);
            border-radius: 4px;
            border-left: 3px solid #4169E1;
        }

        .status-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .status-row:last-child { margin-bottom: 0; }
        .status-label { color: #8899aa; text-transform: uppercase; font-size: 10px; font-weight: bold; }
        .status-value { font-family: 'Courier New', monospace; color: #fff; text-align: right; }
        .highlight-val { color: #4169E1; font-weight: bold; }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .btn {
            background: transparent;
            border: 1px solid #4169E1;
            color: #4169E1;
            padding: 8px 10px;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        .btn:hover { background: #4169E1; color: #fff; box-shadow: 0 0 15px rgba(65, 105, 225, 0.4); }
        .btn.active { background: #4169E1; color: #fff; }

        .geo-metric {
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 8px;
            margin-top: 8px;
        }

        #stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #445566;
            font-size: 10px;
            z-index: 5;
            text-align: right;
        }

        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: #020612; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #1a2b45;
            border-top: 4px solid #4169E1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div style="margin-top: 15px; color: #4169E1; font-size: 12px; letter-spacing: 2px;">CALIBRATING PHYSICS...</div>
    </div>

    <div id="ui-layer">
        <button id="toggle-ui-btn" title="Toggle Menu">&lt;</button>
        
        <h1>Folding 4D simulation</h1>
        <h2>© The Visual Hub 2026</h2>
        
        <div class="seq-display" id="sequence-text"></div>
        
        <div class="status-panel">
            <div class="status-row">
                <span class="status-label">Conformation:</span>
                <span class="status-value highlight-val" id="conf-status">Random Coil</span>
            </div>
            <div class="status-row">
                <span class="status-label">Secondary Struct:</span>
                <span class="status-value" id="struct-status">Disordered</span>
            </div>
            <div class="status-row">
                <span class="status-label">4D State (Time):</span>
                <span class="status-value" id="time-status">0.0 ns</span>
            </div>
            <div class="status-row">
                <span class="status-label">Energy (Est):</span>
                <span class="status-value" id="energy-status">HIGH</span>
            </div>
            
            <div class="geo-metric">
                <div class="status-row">
                    <span class="status-label">Rise per Residue:</span>
                    <span class="status-value" id="rise-val">0.00 Å</span>
                </div>
                <div class="status-row">
                    <span class="status-label">Residues / Turn:</span>
                    <span class="status-value" id="res-turn-val">0.00</span>
                </div>
                <div class="status-row">
                    <span class="status-label">Helical Pitch:</span>
                    <span class="status-value" id="pitch-val">0.00 Å</span>
                </div>
                <div class="status-row">
                    <span class="status-label">End-to-End Dist:</span>
                    <span class="status-value" id="ete-val">0.00 Å</span>
                </div>
            </div>
        </div>

        <div class="control-group">
            <label>Manual Fold Progress</label>
            <input type="range" id="fold-slider" min="0" max="1" step="0.001" value="0">
        </div>

        <div class="button-grid">
            <button id="play-pause" class="btn active">Pause Simulation</button>
            <button id="toggle-membrane" class="btn">Membrane: ON</button>
        </div>
        <button id="reset-sim" class="btn" style="width:100%; margin-top:5px;">Reset Simulation</button>

        <div class="control-group" style="margin-top:15px;">
            <label id="temp-label">System Temperature: 310 K</label>
            <input type="range" id="temp-slider" min="250" max="400" step="1" value="310">
        </div>

        <div class="control-group">
            <label>Simulation Speed</label>
            <input type="range" id="fold-speed-slider" min="0.05" max="1.0" step="0.05" value="0.2">
        </div>

        <div class="control-group">
            <label>Visual Rotation Speed</label>
            <input type="range" id="speed-slider" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="control-group">
            <label>Unfolded Coil Tortuosity</label>
            <input type="range" id="bend-slider" min="0" max="1" step="0.01" value="0.5">
        </div>

        <div class="control-group">
            <label>Stochasticity Seed</label>
            <input type="range" id="stochastic-slider" min="1" max="1000" step="1" value="42">
        </div>
    </div>

    <div id="stats">
        RENDERER: WebGL2<br>
        PHYSICS: Kinetic Langevin Engine<br>
        TIMESCALE: 0 - 5000 ns
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- Data ---
        const SEQUENCE = "AQSLLVPSIIFILAYSLK";
        const AMINO_PROPS = {
            'A': { type: 'hydrophobic', color: 0xffcc00, size: 1.0 },
            'Q': { type: 'polar', color: 0x00ccff, size: 1.2 },
            'S': { type: 'polar', color: 0x00ccff, size: 0.9 },
            'L': { type: 'hydrophobic', color: 0xffaa00, size: 1.3 },
            'V': { type: 'hydrophobic', color: 0xffcc00, size: 1.1 },
            'P': { type: 'hydrophobic', color: 0xffaa00, size: 1.0 },
            'I': { type: 'hydrophobic', color: 0xffaa00, size: 1.3 },
            'F': { type: 'hydrophobic', color: 0xff8800, size: 1.4 },
            'Y': { type: 'hydrophobic', color: 0xffaa00, size: 1.4 },
            'K': { type: 'polar', color: 0x0088ff, size: 1.3 },
        };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020612, 0.02);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 40);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 

        scene.add(new THREE.AmbientLight(0x334455));
        const l1 = new THREE.PointLight(0xffffff, 1, 100); l1.position.set(10, 20, 10); scene.add(l1);
        const l2 = new THREE.PointLight(0x4169E1, 1, 100); l2.position.set(-10, -20, 10); scene.add(l2);

        // --- Molecule Objects ---
        const residues = [];
        const startPositions = []; 
        const endPositions = [];   
        const RESIDUE_COUNT = SEQUENCE.length;

        const CA_DIST = 3.8;      
        const HELIX_RADIUS = 2.3; 
        const HELIX_RISE = 1.5;   
        const HELIX_ROT = 100 * (Math.PI / 180); 

        const helixCenterOffset = (RESIDUE_COUNT * HELIX_RISE) / 2;
        for (let i = 0; i < RESIDUE_COUNT; i++) {
            const theta = i * HELIX_ROT;
            const y = (i * HELIX_RISE) - helixCenterOffset;
            const x = HELIX_RADIUS * Math.cos(theta);
            const z = HELIX_RADIUS * Math.sin(theta);
            endPositions.push(new THREE.Vector3(x, y, z));
        }

        function generateCoil(bendFactor, customSeed = 42) {
            startPositions.length = 0;
            let currentPos = new THREE.Vector3(0, 0, 0);
            startPositions.push(currentPos.clone());
            
            let seed = customSeed;
            const pseudoRandom = () => {
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            };

            for (let i = 1; i < RESIDUE_COUNT; i++) {
                const yBias = 3.4 - (bendFactor * 2.8); 
                const lateralFreedom = 1.0 + (bendFactor * 5.0); 
                
                let dx = (pseudoRandom() - 0.5) * lateralFreedom;
                let dy = yBias + (pseudoRandom() - 0.5); 
                let dz = (pseudoRandom() - 0.5) * lateralFreedom;
                
                dx += Math.sin(i * 0.4) * (bendFactor * 4.5);
                dz += Math.cos(i * 0.4) * (bendFactor * 4.5);
                
                const step = new THREE.Vector3(dx, dy, dz);
                step.normalize().multiplyScalar(CA_DIST);
                
                currentPos.add(step);
                startPositions.push(currentPos.clone());
            }

            const coilCentroid = new THREE.Vector3();
            startPositions.forEach(p => coilCentroid.add(p));
            coilCentroid.divideScalar(RESIDUE_COUNT);
            startPositions.forEach(p => p.sub(coilCentroid));
        }

        generateCoil(0.5);

        const group = new THREE.Group(); scene.add(group);
        const atomGeo = new THREE.SphereGeometry(1, 32, 32);

        for (let i = 0; i < RESIDUE_COUNT; i++) {
            const props = AMINO_PROPS[SEQUENCE[i]];
            const mesh = new THREE.Mesh(atomGeo, new THREE.MeshPhysicalMaterial({ color: props.color, emissive: props.color, emissiveIntensity: 0.5, metalness: 0.1, roughness: 0.2, clearcoat: 1.0 }));
            mesh.scale.setScalar(props.size * 0.6);
            residues.push({ mesh, start: startPositions[i], end: endPositions[i], current: new THREE.Vector3() });
            group.add(mesh);
        }

        const backbone = new THREE.Mesh(new THREE.BufferGeometry(), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, wireframe: true }));
        group.add(backbone);

        const membraneGroup = new THREE.Group();
        const mGeo = new THREE.PlaneGeometry(50, 50, 20, 20);
        const mMat = new THREE.MeshBasicMaterial({ color: 0x4488ff, wireframe: true, transparent: true, opacity: 0.1 });
        const p1 = new THREE.Mesh(mGeo, mMat); p1.rotation.x = -Math.PI/2; p1.position.y = 10;
        const p2 = new THREE.Mesh(mGeo, mMat); p2.rotation.x = -Math.PI/2; p2.position.y = -10;
        membraneGroup.add(p1, p2);
        scene.add(membraneGroup);

        const slider = document.getElementById('fold-slider');
        const playBtn = document.getElementById('play-pause');
        const resetBtn = document.getElementById('reset-sim');
        const membraneBtn = document.getElementById('toggle-membrane');
        const speedSlider = document.getElementById('speed-slider');
        const bendSlider = document.getElementById('bend-slider');
        const stochasticSlider = document.getElementById('stochastic-slider');
        const foldSpeedSlider = document.getElementById('fold-speed-slider');
        const tempSlider = document.getElementById('temp-slider');
        const tempLabel = document.getElementById('temp-label');
        const toggleUIBtn = document.getElementById('toggle-ui-btn');
        const uiLayer = document.getElementById('ui-layer');
        
        const confStatus = document.getElementById('conf-status');
        const structStatus = document.getElementById('struct-status');
        const timeStatus = document.getElementById('time-status');
        const energyStatus = document.getElementById('energy-status');

        const riseVal = document.getElementById('rise-val');
        const pitchVal = document.getElementById('pitch-val');
        const eteVal = document.getElementById('ete-val');
        const resTurnVal = document.getElementById('res-turn-val');

        let foldProgress = 0, targetProgress = 0, isPlaying = true, simTime = 0;
        
        let currentTemp = 310;
        let targetTemp = 310;
        let currentBend = 0.5;
        let targetBend = 0.5;
        let currentSeed = 42;
        let targetSeed = 42;

        let lastFoldProgress = 0; 

        slider.addEventListener('input', (e) => { targetProgress = parseFloat(e.target.value); isPlaying = false; playBtn.innerText = "Play Simulation"; playBtn.classList.remove('active'); });
        playBtn.addEventListener('click', () => { isPlaying = !isPlaying; playBtn.innerText = isPlaying ? "Pause Simulation" : "Play Simulation"; playBtn.classList.toggle('active', isPlaying); });
        resetBtn.addEventListener('click', () => { simTime = 0; targetProgress = 0; foldProgress = 0; lastFoldProgress = 0; });
        membraneBtn.addEventListener('click', () => { membraneGroup.visible = !membraneGroup.visible; membraneBtn.innerText = `Membrane: ${membraneGroup.visible ? 'ON' : 'OFF'}`; });
        
        tempSlider.addEventListener('input', (e) => { 
            targetTemp = parseInt(e.target.value);
            tempLabel.innerText = `System Temperature: ${targetTemp} K`;
        });
        
        bendSlider.addEventListener('input', (e) => {
            targetBend = parseFloat(e.target.value);
        });

        stochasticSlider.addEventListener('input', (e) => {
            targetSeed = parseInt(e.target.value);
        });

        toggleUIBtn.addEventListener('click', () => {
            uiLayer.classList.toggle('collapsed');
            toggleUIBtn.innerHTML = uiLayer.classList.contains('collapsed') ? "&gt;" : "&lt;";
        });

        function updateUI(p) {
            let ns = p * 5000;
            timeStatus.innerText = ns.toFixed(1) + " ns";
            
            const deltaProgress = p - lastFoldProgress;
            const directionLabel = deltaProgress >= 0 ? "decreasing" : "increasing";
            
            let structureLabel = "Folding...";
            if (deltaProgress < -0.0001) {
                structureLabel = "Unfolding...";
            } else if (Math.abs(deltaProgress) < 0.0001) {
                structureLabel = p > 0.5 ? "Folding..." : "Unfolding...";
            }

            if (p < 0.1) {
                energyStatus.innerText = "HIGH";
                energyStatus.style.color = "#ff4444";
                confStatus.innerText = "Random Coil";
                structStatus.innerText = "Disordered";
            } else if (p > 0.9) {
                energyStatus.innerText = "LOCAL MINIMUM";
                energyStatus.style.color = "#4169E1";
                confStatus.innerText = "Native State";
                structStatus.innerText = "Alpha Helix";
            } else {
                energyStatus.innerText = directionLabel;
                const r = Math.floor(255 * (1 - p));
                const b = Math.floor(225 * p);
                energyStatus.style.color = `rgb(${r}, 100, ${b})`;
                confStatus.innerText = "Molten Globule";
                structStatus.innerText = structureLabel;
            }
            
            lastFoldProgress = p;

            let totalRise = 0;
            let totalAngleChange = 0;
            for(let i=0; i < residues.length - 1; i++) {
                totalRise += Math.abs(residues[i+1].mesh.position.y - residues[i].mesh.position.y);
                const v1 = new THREE.Vector3(residues[i].mesh.position.x, 0, residues[i].mesh.position.z).normalize();
                const v2 = new THREE.Vector3(residues[i+1].mesh.position.x, 0, residues[i+1].mesh.position.z).normalize();
                let angle = Math.acos(Math.max(-1, Math.min(1, v1.dot(v2))));
                totalAngleChange += angle;
            }
            const avgRise = totalRise / (RESIDUE_COUNT - 1);
            const avgAnglePerResidue = totalAngleChange / (RESIDUE_COUNT - 1);
            const resPerTurn = avgAnglePerResidue > 0.05 ? (2 * Math.PI) / avgAnglePerResidue : 0;
            
            riseVal.innerText = avgRise.toFixed(2) + " Å";
            resTurnVal.innerText = resPerTurn > 0 ? resPerTurn.toFixed(2) : "∞";
            const dist = residues[0].mesh.position.distanceTo(residues[RESIDUE_COUNT-1].mesh.position);
            eteVal.innerText = dist.toFixed(2) + " Å";
            const pitch = resPerTurn * avgRise;
            pitchVal.innerText = (pitch > 0 && pitch < 100) ? pitch.toFixed(2) + " Å" : "N/A";
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();
            controls.update();

            // TEMP DAMPING RESTORED: Slower alpha (0.05) for smooth temperature transitions
            currentTemp += (targetTemp - currentTemp) * 0.05;
            currentBend += (targetBend - currentBend) * 0.1;

            if (targetSeed !== currentSeed || Math.abs(targetBend - currentBend) > 0.001) {
                currentSeed = targetSeed; 
                generateCoil(currentBend, currentSeed);
                for(let i=0; i<RESIDUE_COUNT; i++) residues[i].start.copy(startPositions[i]);
            }

            if (isPlaying) {
                const speedMult = parseFloat(foldSpeedSlider.value);
                simTime += delta * speedMult; 
                targetProgress = (Math.sin(simTime - Math.PI/2) + 1) / 2;
                slider.value = targetProgress;
            }

            const thermalThreshold = 370;
            const denaturationExtent = Math.max(0, (currentTemp - thermalThreshold) / (400 - thermalThreshold));
            const maxPhysProgress = 1.0 - denaturationExtent;
            const effectiveTarget = Math.min(targetProgress, maxPhysProgress);
            const kineticFactor = Math.max(0.01, (currentTemp - 240) / 70);
            
            foldProgress += (effectiveTarget - foldProgress) * 0.1 * kineticFactor;
            updateUI(foldProgress);

            const curvePoints = [];
            const vibrationBase = (currentTemp / 310) * 0.085; 

            for (let i = 0; i < RESIDUE_COUNT; i++) {
                const r = residues[i];
                const instabilityFactor = 1.5 + (1.0 - foldProgress); 
                const noise = vibrationBase * instabilityFactor;
                const freq = 4 + (currentTemp / 310) * 6;
                
                const nx = Math.sin(elapsed * freq + i * 0.7) * noise;
                const ny = Math.cos(elapsed * (freq * 1.15) + i * 0.9) * noise;
                const nz = Math.sin(elapsed * (freq * 0.85) - i * 0.5) * noise;
                
                r.current.lerpVectors(r.start, r.end, ease(foldProgress));
                r.mesh.position.set(r.current.x + nx, r.current.y + ny, r.current.z + nz);
                curvePoints.push(r.mesh.position.clone());
            }

            backbone.geometry.dispose();
            backbone.geometry = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(curvePoints), 64, 0.2, 8, false);

            const rot = parseFloat(speedSlider.value);
            group.rotation.y += 0.005 * rot;
            membraneGroup.rotation.y += 0.005 * rot;
            renderer.render(scene, camera);
        }

        function ease(t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }

        window.onload = () => {
            let seqHtml = "";
            for(let char of SEQUENCE) seqHtml += `<span style="color:${AMINO_PROPS[char].type === 'hydrophobic' ? '#ffaa00' : '#00aaff'}">${char}</span>`;
            document.getElementById('sequence-text').innerHTML = seqHtml;
            setTimeout(() => { 
                document.getElementById('loader').style.opacity = 0; 
                setTimeout(() => { document.getElementById('loader').style.display='none'; animate(); }, 500); 
            }, 1000);
        };
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>